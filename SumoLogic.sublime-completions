// {
//    "scope": "source.sumo",

//    "completions":
//    [
//     { "trigger": "_collector\t(The name of the Collector (set when the Collector was installed) that received the log message.)", "contents": "_collector=\"$0\"" },
//     { "trigger": "_format\t(An internal Read Only field, You can use _format to see how the timestamp is parsed from the log file.)", "contents": "_format as ${1:<field>}" },
//     { "trigger": "_messageCount\t(A sequence number (per Source) added by the Collector when the message was received.)", "contents": "_messageCount as ${1:<field>}" },
//     { "trigger": "_messageTime\t(The timestamp of the message in milliseconds. If the message doesn't have a timestamp, messageTime uses the receiptTime.)", "contents": "_messageTime as ${1:<field>}\n" },
//     { "trigger": "_receiptTime\t(The time the Collector received the message in milliseconds.)", "contents": "_receiptTime as ${1:<field>}" },
//     { "trigger": "_size\t()", "contents": "_size as ${1:<field>}" },
//     { "trigger": "_sourceCategory\t(This field is created when you enter text into the Source Category field at Source configuration time.)", "contents": "_sourceCategory=\"${1:<string>}\"" },
//     { "trigger": "_sourceHost\t(The host name of the Source. For local Sources the name of the Source is set when you configure the Source.)", "contents": "_sourceHost=\"${1:<string>}\"" },
//     { "trigger": "_sourceName\t(The name of the log file, determined by the path you entered when you configured the Source.)", "contents": "_sourceName=\"${1:<string>}\"" },
//     { "trigger": "_source\t(The name of the Source, determined by the name you entered when you configured the Source.)", "contents": "_source=\"${1:<string>}\"" },
//     { "trigger": "Luhn\t(Luhn algorithm to check credit cards numbs then validates them)", "contents": "| luhn(${1:<cc_num_field_or_string>}) as ${2:<field>}" },
//     { "trigger": "Math-Expressions: abs\t(Calculates the absolute value of x.)", "contents": "| abs(${1:<field>}) as ${1:<field>}" },
//     { "trigger": "Math-Expressions: acos\t(Inverse cosine result is in radians.)", "contents": "| acos(${1:<radians_angle>}) as ${2:<field>}" },
//     { "trigger": "Math-Expressions: asin\t(Inverse sine result is in radians.)", "contents": "| asin(${1:<radians_angle>}) as ${2:<field>}" },
//     { "trigger": "Math-Expressions: sin\t(Sine result is in radians.)", "contents": "| sin(${1:<radians_angle>}) as ${2:<field>}" },
//     { "trigger": "Where compareCIDRPrefix\t(Filter results if the network prefix from an IPv4 address falls within the specified IP subnet. )", "contents": "| where compareCIDRPrefix(${1:<IP_string_or_filed_1>}, ${2:<IP_string_or_filed_2>}, toInt(${3:prefix_length is an integer (0-32)}))\n" },
//     { "trigger": "Where isBlank\t(Filter results if the field value is a null, an empty string or a string containing only whitespace characters.)", "contents": "| where isBlank(${1:<string_field>})\n" },
//     { "trigger": "Where isEmpty\t(Filter results  if the field value is an empty string containing no characters or whitespace.)", "contents": "| where isEmpty(${1:<string_field>})\n" },
//     { "trigger": "Where isNull\t(Filter results  if the field value presented is \"null\".)", "contents": "| where isNull(${1:<any_type_field>})\n" },
//     { "trigger": "Where isNumeric\t(Filter results  if a string is a valid Java number. )", "contents": "| where isNumeric(${1:<string_field>})\n" },
//     { "trigger": "Where isPrivateIP\t(Filter results  if an IPv4 address is private and returns a boolean.)", "contents": "| where isPrivateIP(${1:<IPv4_string_field>})\n" },
//     { "trigger": "Where isPublicIP\t(Filter results  if an IPv4 address is publit and returns a boolean.)", "contents": "| where isPublicIP(${1:<IPv4_string_field>})\n" },
//     { "trigger": "Where isValidIP\t(Filter results  if the value is a valid IP address)", "contents": "| where isValidIP(${1:<IP_string_field>})\n" },
//     { "trigger": "Where isValidIPv4\t(Filter results  if the value is a valid IP v4 address)", "contents": "| where isValidIPv4(${1:<IP_string_field>})\n" },
//     { "trigger": "Where isValidIPv6\t(Filter results  if the value is a valid IP v6 address)", "contents": "| where isValidIPv6(${1:<IP_string_field>})\n" },
//     { "trigger": "accum\t(Calculates the cumulative sum of a field.)", "contents": "| accum ${1:<filed>} as total_of_$1 by ${2:<aggregating_field>}\n" },
//     { "trigger": "avg\t(calculates the average value of the numerical field being evaluated within the time range analyzed)", "contents": "| avg(${1:<numerical_field>}) as ${2:field} ${3:group} by ${4:<aggregating_field>}\n" },
//     { "trigger": "backshift\t(Compares values as they change over time)", "contents": "| backshift ${1:<field>}, ${2:<shift_length>}\n" },
//     { "trigger": "base64Decode\t(Takes a base64 string and converts it to an ASCII string)", "contents": "| base64Decode(\"${1:<string_or_fiel>}\"${2:,\"<encoding> UTF-8 (default)\"}) as ${3:<field>}\n" },
//     { "trigger": "base64Encode\t(Takes an ASCII string and converts it to a base64 string)", "contents": "| base64Encode(${1:<string_field>}) as ${2:<field>}\n" },
//     { "trigger": "concat\t(Allows you to concatenate or join multiple strings, numbers, and fields into a single user-defined field.)", "contents": "| concat(${1:<one_or_more_fields_or_strings>},${2:<field_or_string>}) as ${3:<field>}\n" },
//     { "trigger": "count\t()", "contents": "| count by ${1:<one_or_more_fields>},${2:<field>}\n" },
//     { "trigger": "formatDate\t(Allows you to format dates in US date formatting, European formatting, timestamps, etc.)", "contents": "| formatDate(fromMillis(toLong(${1:<date_time_field_in_milliseconds>})), ${2:<Java_based_date_format_string such as yyyy-MM-dd>}, ${3:ISO TimeZone such as GMT}) as formatted_$1\n" },
//     { "trigger": "format\t(Allows you to format and combine data from parsed fields. Numbers, strings, and dates to user-defined string.)", "contents": "| format(\"${1:format_specifier}\", ${2:<field_1>}, ${3: as many fields as to match the format place .....}) as ${4:<field>}\n" },
//     { "trigger": "getCIDRPrefix\t(Extracts the network prefix from an IPv4 address.)", "contents": "| getCIDRPrefix(${1:<IP_string_or_filed>}, toInt(${3:prefix_length is an integer (0-32)})) as ${1:<field>}\n" },
//     { "trigger": "if\t(Forms of ternary expression you can use in Sumo Logic queries)", "contents": "| if(${1:<condition>}, ${2:<value_if_true>}, ${3:<value_if_false>}) as ${4:<field>}\n" },
//     { "trigger": "isBlank\t(Checks if the field value is a null, an empty string or a string containing only whitespace characters.)", "contents": "| isBlank(${1:<string_field>}) as ${2:<field>}" },
//     { "trigger": "isEmpty\t(Checks if the field value is an empty string containing no characters or whitespace.)", "contents": "| isEmpty(${1:<string_field>}) as ${2:<field>}" },
//     { "trigger": "isNull\t(Checks if the field value presented is \"null\".)", "contents": "| isNull(${1:<any_type_field>}) as ${2:<field>}" },
//     { "trigger": "isNumeric\t(Checks whether a string is a valid Java number. )", "contents": "| isNumeric(${1:<string_field>}) as ${2:<field>}" },
//     { "trigger": "isPrivateIP\t(checks if an IPv4 address is private and returns a boolean.)", "contents": "| isPrivateIP(${1:<IPv4_string_field>}) as ${2:<field>}" },
//     { "trigger": "isPublicIP\t(checks if an IPv4 address is publit and returns a boolean.)", "contents": "| isPublicIP(${1:<IPv4_string_field>}) as ${2:<field>}" },
//     { "trigger": "isValidIP\t(Checks if the value is a valid IP address)", "contents": "| isValidIP(${1:<IP_string_field>}) as ${2:<field>}" },
//     { "trigger": "isValidIPv4\t(Checks if the value is a valid IP v4 address)", "contents": "| isValidIPv4(${1:<IP_string_field>}) as ${2:<field>}" },
//     { "trigger": "isValidIPv6\t(Checks if the value is a valid IP v6 address)", "contents": "| isValidIPv6(${1:<IP_string_field>}) as ${2:<field>}" },
//     { "trigger": "json\t(Allows you to extract values from JSON logs with most JSONPath expressions.)", "contents": "| json ${1:auto} field=${2:<optional_fiel_to_json_parse>} \"${3:<name_or_key>}\", \"${4:<name_or_key,... as many keys as needed to match>}\"" },
//     { "trigger": "maskFromCIDR\t(A utility function that returns a subnet mask for boolean operations with IPv4 addresses.)", "contents": "| maskFromCIDR(toInt(\"${1:prefix_length is an integer (0-32)}\")) as ${2:<field>}\n" },
//     { "trigger": "matching states - transaction\t(Create Ordered or Unordered transactions please use URL for more info)", "contents": "//Sumo Transaction: https://bit.ly/345OcSX\n\n| transaction on ${1:<one_or_more_fields>}\n\t\t\t   with \"*${2:some_string_to_match}*\" as ${3:state_names_1_to_n_multi_comma_seperated_lines}\n\t\t\t   in ${4:<field>}\n\t\t\t   results by ${5:transactions}${6:states}${7:flow${8:\n| count by fromstate, tostate}}\n" },
//     { "trigger": "merge\t(Reduces a stream of events to a single event using a specified merge strategy)", "contents": "| merge ${1:<one_or_more_fields>} ${2:takeFirst}${3:takeLast}${4:join with \"${5:some delimetr such as , or \\n etc.}}\"" },
//     { "trigger": "parse regex\t(Parse Regex operator (also called the extract operator) to extract more complex data from log lines)", "contents": "| parse regex field=${1:<optional_fiel_to_json_parse>} \"${2:<start_expression>}(?<${3:<field_name>}>${4:<regex_string_group_expression>})${5:<end_expression>}\"${6: multi}${7: nodrop}\n" },
//     { "trigger": "parseDate\t(Allows you to parse dates in US date formatting, European formatting, timestamps, etc.)", "contents": "| parseDate(${1:<date_string_or_field>}, ${2:<Java_based_date_format_string such as yyyy-MM-dd>}, \"${3:ISO TimeZone such as GMT}\") as $1_as_datetime\n" },
//     { "trigger": "parse\t(Anchor Pars to extract more complex data from log lines)", "contents": "| parse regex field=${1:<optional_fiel_to_json_parse>} \"${2:<start_string>}*${3:<end_expression>}\" as ${4:<field_1 ... as many * in the expression>}${5: nodrop}\n" },
//     { "trigger": "predefined states - transaction\t(Create Ordered or Unordered transactions please use URL for more info)", "contents": "//Sumo Transaction: https://bit.ly/345OcSX\n\n| transaction on ${1:<one_or_more_fields>}\n\t\t\t   with states ${2:state_names_1_to_n_multi_comma_seperated_fields}\n\t\t\t   in ${3:<field>}\n\t\t\t   results by ${5:transactions}${6:states}${7:flow${8:\n| count by fromstate, tostate}}\n" },
//     { "trigger": "subquery\t(Subqueries allow you to filter a query when you may not be sure of the exact filter criteria)", "contents": "[subquery from=(${1:<optional_fromTime>}) to=(${2:<optional_toTime>}) :\n\n\t${3:<child query>}\n\t| compose ${4:<field_1>}, ${5:<field_2>...}\tmaxresults=${6:<optional_maxresults>} ${7:keywords}\n\n]\n" },
//     { "trigger": "ternary\t(Question Mark ? A ternary expression you can use in Sumo Logic queries)", "contents": "| ${1:<field>} = ${2:<condition>} ? ${3:<value_if_true>} : ${4:<value_if_false}\n" },
//     { "trigger": "timeslice\t(Segregates data by time period, create bucketed results based on EITHER a fixed interval OR number of buckets)", "contents": "| timeslice ${1:#}${2:s|m|h|d|w}${3: buckets}\n" },
//     { "trigger": "tourl\t(Assignes a short name that describes the URL, clickable within a dashboard)", "contents": "| tourl(${1:<url_column_name>}, \"${2:<url_short_name_field_or_string>}\"${3:, ${4:<url_short_name_prefix>}}${5:, ${6:<url_short_name_suffix>}}) as ${7:<field>}\n" },
//     { "trigger": "transactionize\t(Groups log messages that match on any fields you specify, creating transactions upto 50MB of raw logs at a time)", "contents": "| transactionize ${1:<one_or_more_fields>}(merge ${1:<one_or_more_fields>} ${2:takeFirst}${3:takeLast}${4:join with \"${5:some delimetr such as , or \\n etc.}}\")\n" },
//     { "trigger": "transpose\t(Similar to a PivotTable in Excel, takes a list and turn it into a table in the Aggregates tab)", "contents": "| transpose row ${1:<one_or_fields_as_rows>} column ${2:<one_or_more_fields_pivoted_as_columns>}\n" },
//     { "trigger": "urldecode\t(Decodes a URL you include in a query, returning the decoded (unescaped) URL string)", "contents": "| urldecode(${:1<encoded_url_field_or_string>}) as ${2:<field>}\n" },
//     { "trigger": "urlencode\t(Encodes the URL into an ASCII character set, which can sent over the Internet)", "contents": "| urlencode(${:1<unescaped_plain_url_field_or_string>}) as ${2:<field>}\n" },
//    ],

// }
